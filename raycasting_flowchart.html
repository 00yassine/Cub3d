<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cub3D Raycasting Flowchart</title>
    <script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
            color: white;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        h1 {
            text-align: center;
            font-size: 1em;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        h2 {
            color: #ffd700;
            border-bottom: 2px solid #ffd700;
            padding-bottom: 10px;
            margin-top: 40px;
        }
        .flowchart {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        .description {
            background: rgba(255, 255, 255, 0.2);
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #ffd700;
        }
        .code-block {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ® Cub3D Raycasting Flowchart</h1>

        <div class="description">
            <h3>ğŸ“‹ Overview</h3>
            <p>This interactive flowchart shows the complete raycasting process in your Cub3D project, from initialization to 3D rendering.</p>
            <p><strong>What is Raycasting?</strong> Raycasting is a technique for simulating 3D vision by casting imaginary lines from the player's position to find walls and render them on screen.</p>
        </div>

        <div class="description">
            <h3>ğŸ¯ Key Concepts</h3>
            <div class="code-block">
<strong>ğŸ—ï¸ Main Process Flow:</strong>

1ï¸âƒ£ <strong>Initialization</strong>
   â”œâ”€â”€ Read map file (.cub file)
   â”œâ”€â”€ Convert data to 2D array
   â”œâ”€â”€ Find initial player position
   â””â”€â”€ Load wall textures

2ï¸âƒ£ <strong>Game Loop</strong>
   â”œâ”€â”€ Check user input
   â”œâ”€â”€ Update player position
   â”œâ”€â”€ Render 3D scene
   â””â”€â”€ Display result on screen

3ï¸âƒ£ <strong>Raycasting</strong>
   â”œâ”€â”€ Cast ray from player for each screen column
   â”œâ”€â”€ Find first wall that ray hits
   â”œâ”€â”€ Calculate distance from player to wall
   â””â”€â”€ Use distance to calculate wall height

4ï¸âƒ£ <strong>Rendering</strong>
   â”œâ”€â”€ Draw ceiling
   â”œâ”€â”€ Draw textured wall
   â”œâ”€â”€ Draw floor
   â””â”€â”€ Draw minimap
            </div>
        </div>

        <h2>ğŸš€ Main Program Flow</h2>
        <div class="flowchart">
            <div class="mermaid">
                flowchart TD
                    A[ğŸ¯ Start Program] --> B[ğŸ“Š Parse Map File]
                    B --> C[ğŸ—ï¸ Initialize Game Data]
                    C --> D[ğŸ® Start MLX Graphics]
                    D --> E[âš¡ Game Loop Running]
                    E --> F[ğŸ® Check User Input]
                    F --> G[ğŸ‘¤ Move Player if Needed]
                    G --> H[ğŸ–¼ï¸ Clear Previous Frame]
                    H --> I[ğŸŒ Draw 3D View]
                    I --> J[ğŸ—ºï¸ Draw Mini Map]
                    J --> K[ğŸ“º Show Frame to User]
                    K --> E

                    style A fill:#ff6b6b,stroke:#fff,stroke-width:2px,color:#fff
                    style D fill:#4ecdc4,stroke:#fff,stroke-width:2px,color:#000
                    style I fill:#45b7d1,stroke:#fff,stroke-width:2px,color:#fff
                    style J fill:#96ceb4,stroke:#fff,stroke-width:2px,color:#000
            </div>
        </div>

        <h2>ğŸ—ï¸ Initialization Process</h2>
        <div class="flowchart">
            <div class="mermaid">
                flowchart TD
                    A[ğŸ¯ Initialize Game Data] --> B[ğŸ“Š Extract Map Array]
                    B --> C[ğŸ“ Calculate Map Size]
                    C --> D[ğŸ–¥ï¸ Start Graphics System]
                    D --> E[ğŸªŸ Create Game Window]
                    E --> F[ğŸ¨ Create Image Buffer]
                    F --> G[ğŸ§™â€â™‚ï¸ Find Player Position]
                    G --> H[ğŸ® Setup Key Controls]
                    H --> I[ğŸ–¼ï¸ Load Wall Textures]
                    I --> J[ğŸ”„ Start Game Loop]

                    B1[ğŸ“‹ Check if Map Line]
                    B2[ğŸ“¦ Fill Map Data]
                    B --> B1
                    B --> B2

                    G1[ğŸ” Find N/S/E/W Character]
                    G2[ğŸ“ Set Center Position]
                    G3[ğŸ§­ Set Looking Direction]
                    G --> G1
                    G1 --> G2
                    G2 --> G3

                    I1[ğŸŒ† Load 4 Texture Files]
                    I2[ğŸ“Š Get Image Memory]
                    I --> I1
                    I1 --> I2

                    style A fill:#ff6b6b,stroke:#fff,stroke-width:2px,color:#fff
                    style G fill:#feca57,stroke:#fff,stroke-width:2px,color:#000
                    style I fill:#48dbfb,stroke:#fff,stroke-width:2px,color:#000
            </div>
        </div>

        <h2>âš¡ Core Raycasting Algorithm</h2>
        <div class="flowchart">
            <div class="mermaid">
                flowchart TD
                    A[âš¡ Find Wall Distance] --> B[ğŸ“Š Find Horizontal Lines]
                    B --> C[ğŸ“Š Find Vertical Lines]
                    C --> D[ğŸ”„ Step Through Grid Horizontally]
                    D --> E{Hit Wall Horizontally?}
                    E -->|No| F[â¡ï¸ Move to Next Step]
                    F --> D
                    E -->|Yes| G[ğŸ“ Calculate Distance]

                    C --> H[ğŸ”„ Step Through Grid Vertically]
                    H --> I{Hit Wall Vertically?}
                    I -->|No| J[â¡ï¸ Move to Next Step]
                    J --> H
                    I -->|Yes| K[ğŸ“ Calculate Distance]

                    G --> L{Which Distance is Closer?}
                    K --> L
                    L -->|Horizontal| M[âœ… Use Horizontal Hit]
                    L -->|Vertical| N[âœ… Use Vertical Hit]
                    M --> O[ğŸ“Š Save Hit Information]
                    N --> O

                    O --> P[ğŸ¯ Save Hit Coordinates]
                    O --> Q[ğŸ“ Save Final Distance]
                    O --> R[ğŸ” Save Wall Type]

                    style A fill:#ff6b6b,stroke:#fff,stroke-width:2px,color:#fff
                    style E fill:#feca57,stroke:#fff,stroke-width:2px,color:#000
                    style I fill:#feca57,stroke:#fff,stroke-width:2px,color:#000
                    style L fill:#48dbfb,stroke:#fff,stroke-width:2px,color:#000
            </div>
        </div>

        <h2>ğŸŒ 3D Scene Rendering</h2>
        <div class="flowchart">
            <div class="mermaid">
                flowchart TD
                    A[ğŸŒ Draw 3D Scene] --> B[ğŸ”¢ Calculate Ray Step]
                    B --> C[ğŸ§­ Set Starting Angle]
                    C --> D[ğŸ”„ For Each Screen Column]
                    D --> E[âš¡ Cast Ray to Find Wall]
                    E --> F[ğŸ¯ Get Wall Hit Info]
                    F --> G[ğŸ“ Fix Fish-Eye Effect]
                    G --> H[ğŸ¨ Choose Wall Texture]
                    H --> I[ğŸ–¼ï¸ Draw Wall Column]
                    I --> J{More Columns?}
                    J -->|Yes| K[â¡ï¸ Next Column]
                    K --> D
                    J -->|No| L[âœ… 3D Scene Complete]

                    H1{Vertical Wall?}
                    H2[ğŸ–¼ï¸ East or West Texture]
                    H3[ğŸ–¼ï¸ North or South Texture]
                    H --> H1
                    H1 -->|Yes| H2
                    H1 -->|No| H3

                    style A fill:#45b7d1,stroke:#fff,stroke-width:2px,color:#fff
                    style E fill:#ff6b6b,stroke:#fff,stroke-width:2px,color:#fff
                    style I fill:#96ceb4,stroke:#fff,stroke-width:2px,color:#000
            </div>
        </div>

        <h2>ğŸ–¼ï¸ Wall Rendering Process</h2>
        <div class="flowchart">
            <div class="mermaid">
                flowchart TD
                    A[ğŸ–¼ï¸ Draw Wall Column] --> B[ğŸ“ Calculate Wall Height]
                    B --> C[ğŸ“ Find Drawing Limits]
                    C --> D[ğŸ¨ Draw Ceiling Area]
                    D --> E[ğŸ¯ Find Texture Position]
                    E --> F[ğŸ“Š Calculate Texture Step]
                    F --> G[ğŸ”„ For Each Wall Pixel]
                    G --> H[ğŸ¨ Get Texture Color]
                    H --> I[ğŸ–Œï¸ Draw Pixel to Screen]
                    I --> J{More Wall Pixels?}
                    J -->|Yes| L[â¬‡ï¸ Move to Next Pixel]
                    L --> G
                    J -->|No| M[ğŸ¨ Draw Floor Area]
                    M --> N[âœ… Column Finished]

                    E1{Vertical Wall?}
                    E2[ğŸ¯ Use Y-Coordinate]
                    E3[ğŸ¯ Use X-Coordinate]
                    E --> E1
                    E1 -->|Yes| E2
                    E1 -->|No| E3

                    style A fill:#96ceb4,stroke:#fff,stroke-width:2px,color:#000
                    style H fill:#48dbfb,stroke:#fff,stroke-width:2px,color:#000
                    style I fill:#feca57,stroke:#fff,stroke-width:2px,color:#000
            </div>
        </div>

        <h2>ğŸ® Input Handling System</h2>
        <div class="flowchart">
            <div class="mermaid">
                flowchart TD
                    A[ğŸ® Check Movement Input] --> B{W Key Pressed?}
                    B -->|Yes| C[â¡ï¸ Move Forward]
                    A --> D{S Key Pressed?}
                    D -->|Yes| E[â¬…ï¸ Move Backward]
                    A --> F{A Key Pressed?}
                    F -->|Yes| G[â¬…ï¸ Strafe Left]
                    A --> H{D Key Pressed?}
                    H -->|Yes| I[â¡ï¸ Strafe Right]

                    J[ğŸ”„ Check Rotation Input] --> K{Left Arrow?}
                    K -->|Yes| L[â†º Turn Left]
                    J --> M{Right Arrow?}
                    M -->|Yes| N[â†» Turn Right]
                    J --> O{Mouse Moved?}
                    O -->|Yes| P[ğŸ–±ï¸ Look Around]

                    C1[ğŸ§® Calculate New X Position]
                    C2[ğŸ§® Calculate New Y Position]
                    C3{Wall at New X?}
                    C4{Wall at New Y?}
                    C5[âœ… Update X if Safe]
                    C6[âœ… Update Y if Safe]

                    C --> C1
                    C1 --> C2
                    C2 --> C3
                    C2 --> C4
                    C3 -->|No| C5
                    C4 -->|No| C6

                    style A fill:#feca57,stroke:#fff,stroke-width:2px,color:#000
                    style J fill:#ff9ff3,stroke:#fff,stroke-width:2px,color:#000
            </div>
        </div>

        <h2>ğŸ—ºï¸ Minimap Rendering</h2>
        <div class="flowchart">
            <div class="mermaid">
                flowchart TD
                    A[ğŸ—ºï¸ Draw Minimap] --> B[ğŸ”„ For Each Map Tile]
                    B --> C[ğŸ“Š Calculate Screen Position]
                    C --> D[ğŸ“ Relative to Player]
                    D --> E{Tile Visible on Minimap?}
                    E -->|No| F[â­ï¸ Skip This Tile]
                    E -->|Yes| G{Is Wall Tile?}
                    G -->|Yes| H[ğŸ§± Draw Dark Square]
                    G -->|No| I[â¬œ Draw Light Square]
                    H --> J{More Tiles?}
                    I --> J
                    J -->|Yes| K[â¡ï¸ Next Tile]
                    K --> B
                    J -->|No| L[ğŸ‘¤ Draw Player Dot]
                    L --> M[âœ… Minimap Complete]

                    style A fill:#96ceb4,stroke:#fff,stroke-width:2px,color:#000
                    style G fill:#feca57,stroke:#fff,stroke-width:2px,color:#000
                    style L fill:#ff6b6b,stroke:#fff,stroke-width:2px,color:#fff
            </div>
        </div>

        <h2>ğŸ“‹ MLX and Math Library Functions Reference</h2>

        <div class="description">
            <h3>ğŸ–¥ï¸ MLX Graphics Library Functions</h3>
            <div class="code-block">
<strong>mlx_init()</strong>
â”œâ”€â”€ Purpose: Initialize the MLX graphics system
â”œâ”€â”€ Parameters: None
â”œâ”€â”€ Returns: void* - pointer to MLX instance
â”œâ”€â”€ What it does: Sets up the connection to the X11 display server
â”œâ”€â”€ Used in: Initialization phase to start graphics
â””â”€â”€ Example: mlx_ptr = mlx_init();

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”


<strong>mlx_new_window(void *mlx_ptr, int width, int height, char *title)</strong>
â”œâ”€â”€ Purpose: Create a new window for rendering
â”œâ”€â”€ Parameters:
â”‚   â€¢ MLX pointer - the MLX instance
â”‚   â€¢ window width - width in pixels
â”‚   â€¢ window height - height in pixels
â”‚   â€¢ window title - string for title bar
â”œâ”€â”€ Returns: void* - pointer to window instance
â”œâ”€â”€ What it does: Creates a window with specified dimensions and title
â”œâ”€â”€ Used in: Create the main game window (1200x800)
â””â”€â”€ Example: win_ptr = mlx_new_window(mlx_ptr, 1200, 800, "Cub3D");

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

<strong>mlx_new_image(void *mlx_ptr, int width, int height)</strong>
â”œâ”€â”€ Purpose: Create an image buffer for drawing
â”œâ”€â”€ Parameters:
â”‚   â€¢ MLX pointer - the MLX instance
â”‚   â€¢ image width - width in pixels
â”‚   â€¢ image height - height in pixels
â”œâ”€â”€ Returns: void* - pointer to image instance
â”œâ”€â”€ What it does: Allocates memory for an image buffer
â”œâ”€â”€ Used in: Create framebuffer for rendering before display
â””â”€â”€ Example: img = mlx_new_image(mlx_ptr, 1200, 800);

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”


<strong>mlx_get_data_addr(void *img_ptr, int *bpp, int *line_len, int *endian)</strong>
â”œâ”€â”€ Purpose: Get direct access to image pixel data
â”œâ”€â”€ Parameters:
â”‚   â€¢ Image pointer - the image to access
â”‚   â€¢ bits per pixel - pointer to store BPP value
â”‚   â€¢ line length - pointer to store line length
â”‚   â€¢ endianness - pointer to store endian info
â”œâ”€â”€ Returns: char* - pointer to raw image data
â”œâ”€â”€ What it does: Provides direct memory access for fast pixel manipulation
â”œâ”€â”€ Used in: Get image buffer address for my_mlx_pixel_put()
â””â”€â”€ Example: img_addr = mlx_get_data_addr(img, &bpp, &line_len, &endian);

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”


<strong>mlx_put_image_to_window(void *mlx_ptr, void *win_ptr, void *img_ptr, int x, int y)</strong>
â”œâ”€â”€ Purpose: Display the image buffer on the window
â”œâ”€â”€ Parameters:
â”‚   â€¢ MLX pointer - the MLX instance
â”‚   â€¢ window pointer - target window
â”‚   â€¢ image pointer - image to display
â”‚   â€¢ x position - horizontal offset
â”‚   â€¢ y position - vertical offset
â”œâ”€â”€ Returns: int - success status
â”œâ”€â”€ What it does: Copies the image buffer to the window for display
â”œâ”€â”€ Used in: Display the rendered frame to the user
â””â”€â”€ Example: mlx_put_image_to_window(mlx_ptr, win_ptr, img, 0, 0);

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”


<strong>mlx_hook(void *win_ptr, int event, int mask, int (*f)(), void *param)</strong>
â”œâ”€â”€ Purpose: Register event handlers for window events
â”œâ”€â”€ Parameters:
â”‚   â€¢ Window pointer - target window
â”‚   â€¢ event type - type of event (2=KeyPress, 3=KeyRelease, etc.)
â”‚   â€¢ event mask - event mask flags
â”‚   â€¢ callback function - function to call on event
â”‚   â€¢ parameter - data to pass to callback
â”œâ”€â”€ Returns: int - success status
â”œâ”€â”€ What it does: Sets up callbacks for keyboard, mouse, and window events
â”œâ”€â”€ Used in: Setup input handling (key press/release, mouse move, window close)
â””â”€â”€ Example: mlx_hook(win_ptr, 2, 1L<<0, key_press, data);

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”


<strong>mlx_loop_hook(void *mlx_ptr, int (*f)(), void *param)</strong>
â”œâ”€â”€ Purpose: Register a function to be called continuously
â”œâ”€â”€ Parameters:
â”‚   â€¢ MLX pointer - the MLX instance
â”‚   â€¢ callback function - function to call every frame
â”‚   â€¢ parameter - data to pass to callback
â”œâ”€â”€ Returns: int - success status
â”œâ”€â”€ What it does: Sets up the main game loop function
â”œâ”€â”€ Used in: Register update_loop() to run every frame
â””â”€â”€ Example: mlx_loop_hook(mlx_ptr, update_loop, data);

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”


<strong>mlx_loop(void *mlx_ptr)</strong>
â”œâ”€â”€ Purpose: Start the main event loop
â”œâ”€â”€ Parameters:
â”‚   â€¢ MLX pointer - the MLX instance
â”œâ”€â”€ Returns: int - exit status
â”œâ”€â”€ What it does: Begins the main program loop, handling events and rendering
â”œâ”€â”€ Used in: Start the game and keep it running
â””â”€â”€ Example: mlx_loop(mlx_ptr);

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”


<strong>mlx_xpm_file_to_image(void *mlx_ptr, char *filename, int *width, int *height)</strong>
â”œâ”€â”€ Purpose: Load XPM texture files
â”œâ”€â”€ Parameters:
â”‚   â€¢ MLX pointer - the MLX instance
â”‚   â€¢ filename - path to XPM file
â”‚   â€¢ width pointer - stores loaded image width
â”‚   â€¢ height pointer - stores loaded image height
â”œâ”€â”€ Returns: void* - pointer to loaded image
â”œâ”€â”€ What it does: Loads texture images from XPM files
â”œâ”€â”€ Used in: Load wall textures (North, South, East, West)
â””â”€â”€ Example: tex_img = mlx_xpm_file_to_image(mlx_ptr, "texture.xpm", &w, &h);
            </div>
        </div>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->

        <div class="description">
            <h3>ğŸ“ Math Library Functions</h3>
            <div class="code-block">
<strong>cos(double angle)</strong>
â”œâ”€â”€ Purpose: Calculate cosine of an angle
â”œâ”€â”€ Parameters: angle in radians
â”œâ”€â”€ Returns: double - cosine value (-1.0 to 1.0)
â”œâ”€â”€ What it does: Returns the cosine of the given angle
â”œâ”€â”€ Used in: Calculate X component of movement and raycasting
â”œâ”€â”€ Header: #include &lt;math.h&gt;
â””â”€â”€ Example: new_x = player_x + cos(player_angle) * speed;

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”


<strong>sin(double angle)</strong>
â”œâ”€â”€ Purpose: Calculate sine of an angle
â”œâ”€â”€ Parameters: angle in radians
â”œâ”€â”€ Returns: double - sine value (-1.0 to 1.0)
â”œâ”€â”€ What it does: Returns the sine of the given angle
â”œâ”€â”€ Used in: Calculate Y component of movement and raycasting
â”œâ”€â”€ Header: #include &lt;math.h&gt;
â””â”€â”€ Example: new_y = player_y + sin(player_angle) * speed;

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”


<strong>tan(double angle)</strong>
â”œâ”€â”€ Purpose: Calculate tangent of an angle
â”œâ”€â”€ Parameters: angle in radians
â”œâ”€â”€ Returns: double - tangent value
â”œâ”€â”€ What it does: Returns the tangent of the given angle (sin/cos)
â”œâ”€â”€ Used in: Calculate ray intersections with grid lines
â”œâ”€â”€ Header: #include &lt;math.h&gt;
â””â”€â”€ Example: x = player_x + (y - player_y) / tan(ray_angle);

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”


<strong>fmod(double x, double y)</strong>
â”œâ”€â”€ Purpose: Calculate floating-point remainder
â”œâ”€â”€ Parameters: dividend (x), divisor (y)
â”œâ”€â”€ Returns: double - remainder of x/y
â”œâ”€â”€ What it does: Returns the floating-point remainder of division
â”œâ”€â”€ Used in: Calculate texture coordinates, wrap values within texture bounds
â”œâ”€â”€ Header: #include &lt;math.h&gt;
â””â”€â”€ Example: tex_x = fmod(hit_x, TILE_SIZE) * tex_width / TILE_SIZE;

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”


<strong>hypot(double x, double y)</strong>
â”œâ”€â”€ Purpose: Calculate hypotenuse (Euclidean distance)
â”œâ”€â”€ Parameters: x coordinate difference, y coordinate difference
â”œâ”€â”€ Returns: double - distance = sqrt(xÂ² + yÂ²)
â”œâ”€â”€ What it does: Calculates the distance between two points
â”œâ”€â”€ Used in: Calculate distance from player to wall hit point
â”œâ”€â”€ Header: #include &lt;math.h&gt;
â””â”€â”€ Example: distance = hypot(hit_x - player_x, hit_y - player_y);

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”


<strong>atan2(double y, double x)</strong>
â”œâ”€â”€ Purpose: Calculate angle from origin to point (x,y)
â”œâ”€â”€ Parameters: y coordinate, x coordinate
â”œâ”€â”€ Returns: double - angle in radians (-Ï€ to Ï€)
â”œâ”€â”€ What it does: Returns the angle of a vector pointing to (x,y)
â”œâ”€â”€ Used in: Calculate angles for raycasting and player orientation
â”œâ”€â”€ Header: #include &lt;math.h&gt;
â””â”€â”€ Example: angle = atan2(target_y - player_y, target_x - player_x);

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”


<strong>sqrt(double x)</strong>
â”œâ”€â”€ Purpose: Calculate square root
â”œâ”€â”€ Parameters: number to find square root of
â”œâ”€â”€ Returns: double - square root value
â”œâ”€â”€ What it does: Returns the square root of the given number
â”œâ”€â”€ Used in: Distance calculations (though hypot() is preferred)
â”œâ”€â”€ Header: #include &lt;math.h&gt;
â””â”€â”€ Example: distance = sqrt(dx * dx + dy * dy);

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”


<strong>floor(double x)</strong>
â”œâ”€â”€ Purpose: Round down to nearest integer
â”œâ”€â”€ Parameters: floating-point number
â”œâ”€â”€ Returns: double - largest integer â‰¤ x
â”œâ”€â”€ What it does: Rounds down to the nearest whole number
â”œâ”€â”€ Used in: Convert world coordinates to map grid coordinates
â”œâ”€â”€ Header: #include &lt;math.h&gt;
â””â”€â”€ Example: map_x = (int)floor(world_x / TILE_SIZE);

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”


<strong>ceil(double x)</strong>
â”œâ”€â”€ Purpose: Round up to nearest integer
â”œâ”€â”€ Parameters: floating-point number
â”œâ”€â”€ Returns: double - smallest integer â‰¥ x
â”œâ”€â”€ What it does: Rounds up to the nearest whole number
â”œâ”€â”€ Used in: Calculate drawing bounds and texture sampling
â”œâ”€â”€ Header: #include &lt;math.h&gt;
â””â”€â”€ Example: end_pixel = (int)ceil(wall_end);
            </div>
        </div>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->

        <div class="description">
            <h3>ğŸ”§ Additional Utility Functions</h3>
            <div class="code-block">
<strong>abs(int x)</strong>
â”œâ”€â”€ Purpose: Calculate absolute value of integer
â”œâ”€â”€ Parameters:
â”‚   â€¢ x - integer value
â”œâ”€â”€ Returns: int - absolute value (always positive)
â”œâ”€â”€ What it does: Returns the positive version of a number
â”œâ”€â”€ Used in: Distance calculations and coordinate differences
â”œâ”€â”€ Header: #include &lt;stdlib.h&gt;
â””â”€â”€ Example: distance = abs(x2 - x1) + abs(y2 - y1);

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”


<strong>malloc(size_t size)</strong>
â”œâ”€â”€ Purpose: Allocate dynamic memory
â”œâ”€â”€ Parameters:
â”‚   â€¢ size - number of bytes to allocate
â”œâ”€â”€ Returns: void* - pointer to allocated memory (or NULL if failed)
â”œâ”€â”€ What it does: Reserves a block of memory on the heap
â”œâ”€â”€ Used in: Allocate memory for map arrays and data structures
â”œâ”€â”€ Header: #include &lt;stdlib.h&gt;
â””â”€â”€ Example: map = malloc(rows * sizeof(char*));

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”


<strong>free(void *ptr)</strong>
â”œâ”€â”€ Purpose: Free previously allocated memory
â”œâ”€â”€ Parameters:
â”‚   â€¢ ptr - pointer to memory to free
â”œâ”€â”€ Returns: void
â”œâ”€â”€ What it does: Releases memory back to the system
â”œâ”€â”€ Used in: Clean up allocated memory when exiting
â”œâ”€â”€ Header: #include &lt;stdlib.h&gt;
â””â”€â”€ Example: free(map[i]);

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”


<strong>memset(void *ptr, int value, size_t num)</strong>
â”œâ”€â”€ Purpose: Set memory to a specific value
â”œâ”€â”€ Parameters:
â”‚   â€¢ ptr - memory pointer
â”‚   â€¢ value - value to set
â”‚   â€¢ num - number of bytes
â”œâ”€â”€ Returns: void* - pointer to the memory area
â”œâ”€â”€ What it does: Fills memory with a specific byte value
â”œâ”€â”€ Used in: Clear image buffer (set all pixels to 0)
â”œâ”€â”€ Header: #include &lt;string.h&gt;
â””â”€â”€ Example: memset(img_data, 0, width * height * 4);
            </div>
        </div>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->

        <div class="description">
            <h3>âš™ï¸ Key Constants & Mathematical Details</h3>
            <div class="code-block">
<strong>ğŸ”¢ Important Constants:</strong>
TS = 64                â†’ Tile Size (pixels per map cell)
FOV = 1.0              â†’ Field of View (radians â‰ˆ 57.3Â°)
SCREEN_WIDTH = 1200    â†’ Window Width (number of rays cast)
SCREEN_HEIGHT = 800    â†’ Window Height
MOVE_SPEED = 2.0       â†’ Movement Speed (pixels per frame)
ROT_SPEED = 0.02       â†’ Rotation Speed (radians per frame)

<strong>ğŸ“ Mathematical Formulas Used:</strong>

ğŸ¯ <strong>Ray Casting:</strong>
â”œâ”€â”€ Horizontal intercept: x = px + (y - py) / tan(angle)
â”‚   â””â”€â”€ Calculates where ray intersects horizontal grid line
â”œâ”€â”€ Vertical intercept: y = py + (x - px) Ã— tan(angle)
â”‚   â””â”€â”€ Calculates where ray intersects vertical grid line
â”œâ”€â”€ Distance: hypot(hit_x - px, hit_y - py)
â”‚   â””â”€â”€ Euclidean distance from player to hit point
â””â”€â”€ Fisheye correction: dist Ã— cos(ray_angle - player_angle)
    â””â”€â”€ Prevents visual distortion at screen edges

ğŸ–¼ï¸ <strong>3D Projection:</strong>
â”œâ”€â”€ Wall height: (TS Ã— SCREEN_HEIGHT) / distance
â”‚   â””â”€â”€ Farther walls appear shorter on screen
â”œâ”€â”€ Texture X: fmod(hit_coordinate, TS) Ã— tex_width / TS
â”‚   â””â”€â”€ Which part of texture to sample horizontally
â”œâ”€â”€ Texture step: tex_height / wall_height
â”‚   â””â”€â”€ How much to advance in texture per screen pixel
â””â”€â”€ Texture Y: (int)tex_pos % tex_height
    â””â”€â”€ Vertical position in texture

ğŸ‘¤ <strong>Movement:</strong>
â”œâ”€â”€ Forward: new_x = x + cos(angle) Ã— speed
â”œâ”€â”€ Forward: new_y = y + sin(angle) Ã— speed
â”‚   â””â”€â”€ Movement in direction player is facing
â”œâ”€â”€ Strafe: angle Â± Ï€/2 for left/right movement
â”‚   â””â”€â”€ Ï€/2 = 90 degrees, perpendicular to view direction
â””â”€â”€ Rotation: angle += delta Ã— sensitivity
    â””â”€â”€ Change view direction based on mouse/key input

ğŸ—ºï¸ <strong>Minimap:</strong>
â”œâ”€â”€ Screen X: (world_x - player_x) / scale + center_x
â”œâ”€â”€ Screen Y: (world_y - player_y) / scale + center_y
â”‚   â””â”€â”€ Convert world position to minimap position
â””â”€â”€ Scale factor: TILE_SIZE / SCALE_FACTOR (64/8 = 8)
    â””â”€â”€ Every 8 world pixels = 1 minimap pixel
            </div>
        </div>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->

        <div class="description">
            <h3>ğŸš€ Algorithm Complexity & Performance</h3>
            <div class="code-block">
<strong>âš¡ Raycasting Performance:</strong>
â”œâ”€â”€ Time Complexity: O(n Ã— m) where n = screen width, m = average ray length
â”œâ”€â”€ Space Complexity: O(1) - constant memory usage
â”œâ”€â”€ Rays per frame: 1200 (one per column)
â”œâ”€â”€ Average ray steps: ~10-20 grid intersections per ray
â””â”€â”€ Total operations: ~12,000-24,000 per frame

<strong>ğŸ¨ Rendering Performance:</strong>
â”œâ”€â”€ Pixel operations per frame: 1200 Ã— 800 = 960,000
â”œâ”€â”€ Texture samples: ~400,000 (wall pixels only)
â”œâ”€â”€ Memory writes: 960,000 pixels Ã— 4 bytes = 3.84MB per frame
â””â”€â”€ Frame rate target: 60 FPS (16.67ms per frame)

<strong>ğŸ”§ Optimization Techniques:</strong>
â”œâ”€â”€ DDA Algorithm: Efficient grid traversal
â”œâ”€â”€ Fisheye Correction: Prevents visual distortion
â”œâ”€â”€ Texture Caching: Preloaded XPM data
â”œâ”€â”€ Fast Pixel Writing: Direct memory access
â””â”€â”€ Collision Detection: Early termination on wall hit
            </div>
        </div>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->

        <div class="description">
            <h3>ğŸ“Š Data Structures & Their Usage</h3>
            <div class="code-block">
<strong>t_data - Main Game State:</strong>
â”œâ”€â”€ map: char** - 2D map array ('1' = wall, '0' = empty, 'N/S/E/W' = player spawn)
â”œâ”€â”€ player: t_player - Player position and angle
â”œâ”€â”€ mlx_ptr, win_ptr, img: MLX graphics pointers
â”œâ”€â”€ img_adr: char* - Direct access to image buffer for fast pixel writing
â”œâ”€â”€ tex[4]: t_tex - Array of 4 wall textures (North/South/East/West)
â”œâ”€â”€ floor, ceiling: t_color - RGB colors for floor and ceiling
â”œâ”€â”€ input: t_input - Current input state flags
â””â”€â”€ rows, cols: int - Map dimensions

<strong>t_player - Player State:</strong>
â”œâ”€â”€ fpx, fpy: double - Precise floating-point position
â”œâ”€â”€ x, y: int - Integer position (rounded for collision)
â”œâ”€â”€ angle: double - Viewing direction in radians (0 = East, Ï€/2 = South)
â””â”€â”€ Used in: movement, rotation, raycasting

<strong>t_hit - Ray Hit Information:</strong>
â”œâ”€â”€ dist: double - Distance from player to wall
â”œâ”€â”€ hit_x, hit_y: double - Exact coordinates of wall intersection
â”œâ”€â”€ is_vertical: int - Flag: 1 = vertical wall, 0 = horizontal wall
â”œâ”€â”€ tex_id: int - Which texture to use (0=North, 1=South, 2=East, 3=West)
â”œâ”€â”€ ray_angle: double - Angle of the ray that hit the wall
â””â”€â”€ Used in: raycasting result, texture selection, 3D rendering

<strong>t_input - Input State:</strong>
â”œâ”€â”€ k_up, k_down: int - W/S movement flags
â”œâ”€â”€ k_left, k_right: int - Arrow key rotation flags
â”œâ”€â”€ k_view_left, k_view_right: int - A/D strafe flags
â””â”€â”€ Updated by: key_press/key_release, used by: handle_movement/handle_rotation

<strong>t_tex - Texture Data:</strong>
â”œâ”€â”€ img: void* - MLX image pointer
â”œâ”€â”€ addr: char* - Direct memory access to texture pixels
â”œâ”€â”€ width, height: int - Texture dimensions
â”œâ”€â”€ bpp, line_len: int - Bytes per pixel and line length
â””â”€â”€ Used in: texture sampling during wall rendering

<strong>t_color - RGB Color:</strong>
â”œâ”€â”€ r, g, b: int - Red, green, blue values (0-255)
â”œâ”€â”€ Converted to hex: (r << 16) | (g << 8) | b
â””â”€â”€ Used for: floor, ceiling, minimap colors
            </div>
        </div>

        <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->

        <div class="description">
            <h3>ğŸ”„ Complete Execution Flow</h3>
            <div class="code-block">
<strong>ğŸ“‹ Step-by-Step Program Execution:</strong>

1ï¸âƒ£ <strong>Program Startup (main.c):</strong>
   â”œâ”€â”€ Parse command line arguments
   â”œâ”€â”€ Call parce() to read and validate .cub file
   â”œâ”€â”€ Call start() with parsed map data
   â””â”€â”€ Exit and cleanup

2ï¸âƒ£ <strong>Engine Initialization (start.c):</strong>
   â”œâ”€â”€ Call init_data_from_map()
   â”œâ”€â”€ Start mlx_loop() - begins event handling
   â””â”€â”€ Program runs until exit

3ï¸âƒ£ <strong>Data Setup (1_init.c):</strong>
   â”œâ”€â”€ extract_map_from_parsed_data() - convert file to 2D array
   â”œâ”€â”€ count_map_dimensions() - get map size
   â”œâ”€â”€ mlx_init() - initialize graphics library
   â”œâ”€â”€ mlx_new_window() - create display window
   â”œâ”€â”€ mlx_new_image() - create image buffer
   â”œâ”€â”€ init_player_pos() - find spawn point and direction
   â”œâ”€â”€ Setup input hooks (key_press, key_release, mouse_move, close_window)
   â”œâ”€â”€ init_textures() - load wall textures
   â””â”€â”€ mlx_loop_hook(update_loop) - set main game loop

4ï¸âƒ£ <strong>Game Loop (5_update_player_pos.c):</strong>
   â”œâ”€â”€ handle_movement() - process WASD input
   â”œâ”€â”€ handle_rotation() - process arrow keys and mouse
   â”œâ”€â”€ clear_img() - reset image buffer to black
   â”œâ”€â”€ draw_3d() - render 3D scene
   â”œâ”€â”€ draw_minimap() - render 2D overlay
   â”œâ”€â”€ mlx_put_image_to_window() - display frame
   â””â”€â”€ Return to MLX (repeats ~60 times per second)

5ï¸âƒ£ <strong>Input Processing (4_input.c):</strong>
   â”œâ”€â”€ key_press() sets input flags to 1
   â”œâ”€â”€ key_release() sets input flags to 0
   â”œâ”€â”€ mouse_move() updates player angle
   â””â”€â”€ close_window() triggers cleanup and exit

6ï¸âƒ£ <strong>Movement Processing (5_update_player_pos.c):</strong>
   â”œâ”€â”€ Check each input flag (k_up, k_down, k_view_left, k_view_right)
   â”œâ”€â”€ Calculate movement angle (forward/backward/strafe)
   â”œâ”€â”€ Call move() with calculated angle
   â”œâ”€â”€ move() calculates new position using trigonometry
   â”œâ”€â”€ Check collision with is_wall() before updating position
   â””â”€â”€ Update player.fpx, player.fpy if movement is safe

7ï¸âƒ£ <strong>3D Rendering (7_draw_3d.c):</strong>
   â”œâ”€â”€ Calculate ray step: FOV / SCREEN_WIDTH
   â”œâ”€â”€ Start angle: player.angle - FOV/2
   â”œâ”€â”€ For each screen column (x = 0 to 1199):
   â”‚   â”œâ”€â”€ Call get_distance() to cast ray
   â”‚   â”œâ”€â”€ Apply fisheye correction: dist *= cos(ray_angle - player_angle)
   â”‚   â”œâ”€â”€ Determine texture ID based on wall face
   â”‚   â”œâ”€â”€ Call draw_wall_3d() to render column
   â”‚   â””â”€â”€ Increment angle for next column
   â””â”€â”€ All columns rendered

8ï¸âƒ£ <strong>Raycasting (6_get_distance.c):</strong>
   â”œâ”€â”€ get_horizontal_intercept() - find first horizontal grid line
   â”œâ”€â”€ get_vertical_intercept() - find first vertical grid line
   â”œâ”€â”€ Step through horizontal grid using get_next_intercept()
   â”œâ”€â”€ Step through vertical grid using get_next_intercept()
   â”œâ”€â”€ Check is_wall() at each intersection
   â”œâ”€â”€ Calculate distances using hypot()
   â”œâ”€â”€ Return closest hit in t_hit struct
   â””â”€â”€ Hit data used for wall rendering

9ï¸âƒ£ <strong>Wall Rendering (7_draw_3d.c):</strong>
   â”œâ”€â”€ Calculate wall height: (TS * SCREEN_HEIGHT) / distance
   â”œâ”€â”€ Calculate draw bounds: start/end points on screen
   â”œâ”€â”€ Draw ceiling pixels using rgb_to_hex(ceiling_color)
   â”œâ”€â”€ Calculate texture coordinates
   â”œâ”€â”€ For each wall pixel:
   â”‚   â”œâ”€â”€ Sample texture color at (tex_x, tex_y)
   â”‚   â”œâ”€â”€ Call my_mlx_pixel_put() to write to buffer
   â”‚   â””â”€â”€ Increment texture position
   â”œâ”€â”€ Draw floor pixels using rgb_to_hex(floor_color)
   â””â”€â”€ Column complete

ğŸ”Ÿ <strong>Minimap Rendering (2_draw_2D_map.c):</strong>
   â”œâ”€â”€ For each map tile:
   â”‚   â”œâ”€â”€ Calculate screen position relative to player
   â”‚   â”œâ”€â”€ Check if tile is within minimap bounds
   â”‚   â”œâ”€â”€ Draw colored square (dark=wall, light=empty)
   â”‚   â””â”€â”€ Continue to next tile
   â”œâ”€â”€ draw_player() - red dot at minimap center
   â””â”€â”€ Minimap overlay complete

ğŸ“º <strong>Frame Display:</strong>
   â”œâ”€â”€ mlx_put_image_to_window() copies buffer to screen
   â”œâ”€â”€ Frame displayed to user
   â”œâ”€â”€ Return to game loop
   â””â”€â”€ Process continues at 60 FPS
            </div>
        </div>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'base',
            themeVariables: {
                primaryColor: '#45b7d1',
                primaryTextColor: '#000',
                primaryBorderColor: '#fff',
                lineColor: '#333',
                secondaryColor: '#96ceb4',
                tertiaryColor: '#feca57'
            }
        });
    </script>
</body>
</html>
